#[builtin("Unit")]
struct Unit {}

#[builtin("Never")]
enum Never {}

#[builtin("U8")]
type U8
#[builtin("U16")]
type U16
#[builtin("U32")]
type U32
#[builtin("U64")]
type U64
#[builtin("I8")]
type I8
#[builtin("I16")]
type I16
#[builtin("I32")]
type I32
#[builtin("I64")]
type I64

#[builtin("USize")]
type USize
#[builtin("ISize")]
type ISize

#[builtin("Runtime")]
type Runtime

#[builtin("Bool")]
enum Bool {
    false: Unit,
    true: Unit,
}

struct Foo {
    member: Unit,
    member2: I8,
}

fn main(runtime: Runtime) {
    print_i32(5, runtime)
    print_i32(10, runtime)

    // declaring variables
    let foo = _ {
        member: Unit {},
        member2: 5,
    }

    // reassigning variables
    foo = Foo {
        member: {}, // shorter way to construct the Unit type, just make the compiler do it for you
        member2: 6,
    }

    foo.member
}

// below main to prove that out-of-order declarations work
#[builtin("print_i32")]
fn print_i32(value: I32, runtime: Runtime)

fn random_testing() {
    // recursive functions work
    fn recursive() {
        recursive()
    }

    // mutually recursive functions work
    fn a() {
        b()
    }

    fn b() {
        a()
    }

    struct A {}

    struct B {
        a: A,
    }

    fn match_testing(b: B) -> A {
        match b {
            B { a: let c } => c,
        }
    }

    fn bool_testing(cond: Bool) -> I32 {
        match cond {
            Bool { true: _ {} } => 1,
            Bool { false: _ {} } => 0,
        }
    }

    fn more_bool_testing(cond: Bool) -> I32 {
        if cond {
            1
        } else {
            0
        }
    }

    fn label_testing() 'return: {
        break 'return
    }

    fn label_testing2() -> I32 'return: {
        break 'return 5
    }

    fn label_testing3() -> Never 'loop: {
        continue 'loop
    }

    fn while_loop(cond: Bool) {
        while cond {}
    }
}
