#builtin("Unit")
struct Unit {}

#builtin("Never")
enum Never {}

#builtin("I32")
type I32

#builtin("Runtime")
type Runtime

#builtin("Bool")
enum Bool {
    false: Unit,
    true: Unit,
}

struct Foo {
    member: Unit,
    member2: I32,
}

fn main(runtime: Runtime) {
    print_i32(5, runtime)
    print_i32(10, runtime)

    // declaring variables
    let foo = _ {
        member: Unit {},
        member2: 5,
    }

    // reassigning variables
    foo = Foo {
        member: {}, // shorter way to construct the Unit type, just make the compiler do it for you
        member2: 6,
    }

    foo.member
}

// below main to prove that out-of-order declarations work
#builtin("print_i32")
fn print_i32(value: I32, runtime: Runtime)

// recursive functions work
fn recursive() {
    recursive()
}

// mutually recursive functions work
fn a() {
    b()
}

fn b() {
    a()
}

struct A {}

struct B {
    a: A,
}

fn match_testing(b: B) -> A {
    match b {
        B { a: let c } => c,
    }
}

fn bool_testing(cond: Bool) -> I32 {
    match cond {
        Bool { true: _ {} } => 1,
        Bool { false: _ {} } => 0,
    }
}

fn more_bool_testing(cond: Bool) -> I32 {
    if cond {
        1
    } else {
        0
    }
}

fn label_testing() 'return: {
    break 'return
}

fn label_testing2() -> I32 'return: {
    break 'return 5
}

fn label_testing3() -> Never 'loop: {
    continue 'loop
}

fn while_loop(cond: Bool) {
    while cond {}
}
